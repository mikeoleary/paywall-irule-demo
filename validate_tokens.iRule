when RULE_INIT {
    set static::stripe_redirect_url "https://demo.my-f5.com/pricing"
    set static::redis_validate_ip "10.0.2.4"
    set static::redis_validate_url "http://10.0.2.4:5000/validate"
    log local0. "Paywall iRule initialized"
    #Set a static variable to control debug logging. 1 = enabled, 0 = disabled
    set static::validate_tokens_debug 1
}

when HTTP_REQUEST {
    
    set path [string tolower [HTTP::path]]
    set uri [string tolower [HTTP::uri]]

    # send the /stripe-webhook URI to the redis proxy to persist the entitlement_token in redis
    if { $uri starts_with "/stripe-webhook" }  {
       pool redis-pool-5000
    }
    
    # send the /pricing URI to our paywall app to generate a checkout URL
    if { $path eq "/pricing" }  {
       pool redis-pool-5000
    }

    # Only protect the premium endpoint
    if { [class match $path equals dg_premium_endpoints] } {
    
        if { $static::validate_tokens_debug } {
            log local0. "Received request from IP [IP::client_addr] for URI: $uri"
        }
        
        # 1. Extract token
        if { $uri contains "entitlement_token=" } {
            # parse from query string
            set token [URI::query $uri "entitlement_token"]
            if { $static::validate_tokens_debug } {
              log local0. "token found in query string is $token"
            }
        } elseif { [HTTP::header exists "X-Entitlement-Token"] } {
            set token [HTTP::header "X-Entitlement-Token"]
            if { $static::validate_tokens_debug } {
              log local0. "token found in header X-Entitlement-Token is $token"
            }
        } else {
            set token ""
            if { $static::validate_tokens_debug } {
              log local0. "no entitlement token was found in the request for $uri"
            }
        }

        # 2. If no token â†’ rewrite the path to /pricing to generate a response including a checkout URL
        if { $token eq "" } {
            HTTP::uri "/pricing"
            HTTP::header insert "x-requested-endpoint" $path
            HTTP::header insert "x-price-id" [class match -value $path equals dg_premium_endpoints]
            pool redis-pool-5000
            return
        }

        # 3. Validate token via Redis-proxy HTTP

        # Create validation request to backend
        set validation_request "GET /validate HTTP/1.1\r\n"
        append validation_request "Host: ${static::redis_validate_ip}\r\n"
        append validation_request "Connection: close\r\n"
        append validation_request "X-Entitlement-Token: $token\r\n"
        append validation_request "\r\n"
        
        # Make HTTP call to backend validation endpoint
        set conn [connect -timeout 5000 -idle 30 ${static::redis_validate_ip}:5000 ]
        send $conn $validation_request
        
        # Read response
        set response [recv -timeout 5000 $conn]
        close $conn
        
        # Log response from validation request
        if { [regexp {HTTP/1\.[01] (\d+)} $response -> status_code] } {
          # Extract response body (content after double CRLF)
          if { [regexp {\r\n\r\n(.*)$} $response -> response_body] } {
            if { $static::validate_tokens_debug } {
              log local0. "Validation response body: $response_body"
            }
          } else {
            if { $static::validate_tokens_debug } {
              log local0. "Validation response body: (empty or malformed)"
            }
          }
          switch $status_code {
            "200" {
                # Validation successful - return 200 OK
                if { $static::validate_tokens_debug } {
                  log local0. "Token validation successful for token $token"
                }
            }
            default {
                # Validation failed, send them to /pricing endpoint
                HTTP::uri "/pricing"
                HTTP::header insert "x-requested-endpoint" $path
                HTTP::header insert "x-price-id" [class match -value $path equals dg_premium_endpoints]
                pool redis-pool-5000
                return
            }
        }
        } else {
          # Unable to parse response or connection to validation endpoint failed, send to the /pricing endpoint
          HTTP::uri "/pricing"
          HTTP::header insert "x-requested-endpoint" $path
          HTTP::header insert "x-price-id" [class match -value $path equals dg_premium_endpoints]
          pool redis-pool-5000
          return
        }
  }
}